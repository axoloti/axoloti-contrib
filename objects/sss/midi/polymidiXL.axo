<objdefs appVersion="1.0.12">
   <obj.normal id="polymidiXL" uuid="ad3450a4-53f5-4d52-a98d-b54f6d95dd72">
      <sDescription>&quot;Monophonic MIDI keyboard note input, gate, velocity and release velocity&quot;..... well, yes, that&apos;s where it started.. XD

This is now a polyphonic midi-recorder, able to record midinotes from every channel and 2 ports (internal/DIN).
Each channel can be set to be editted (whether it&apos;s recording or only sending thru the played midi to play along with your recording)
Each channel/port can be muted independently
Each channel/port can be solo&apos;d + added to solo&apos;d channels
Each channel can use the scaling of the 46 scales in the scale7bank (used with pads, unused notes are just skipped, 7 pads=1 octave)

Read-and write- counterposition can be set independently. This also allows for timing-adjustments (eg. delay the writeposition in respect to the read-position when you have latency)
The counter can be set pretty fast as it just records positions where recorded notes should be played. So eg. you could run at 192x host tempo with a maxcount of 24*64 to have a short but lively (unquantized) sequence.

Don&apos;t forget to send a &quot;gate-high&quot; to the &quot;active&quot; input when you want the sequencer to actually be active and do something..

Amount of maximum notes to be recorded is set by the &quot;size&quot; attribute. I set it to 8129... never passed it and quick loading time.

Several midi-fx are added:
&quot;copy&quot;: this copies from a part (from min/max) of the selected &quot;edit&quot; channels to a part (to min/max) of the channels &quot;former channel&quot;+&quot;toChannelOffset&quot;. So:
if the &quot;edit&quot; of channels 1,2,3,4 is &quot;on&quot; and &quot;toChannelOffset&quot; is set to 5, it will copy these channels to channels 6,7,8,9 respectively.

&quot;delay&quot;: this adds delayed midi-notes to the existing midi-pattern. The amount of repeats can be set as well as transposition, time and velocity-decay. &quot;bound&quot; will loop delayed notes if they surpass the maximum count.

&quot;DelChnl&quot; deletes only one channel
&quot;erase&quot; erases all channels
&quot;undo&quot; erases last 64 notes (not sure if that&apos;s so very helpful..)

It&apos;s possible to control the channel edit/mute/solo/scaled over midi using midichannel 1. sending a midiCC 57,58,59,60 set the bar to edit (0=edit/1=mute/2=solo/3=scaled)
Sending midiCC 1 to 16 on midichannel2 toggles the seperate steps.</sDescription>
      <author>Remco van der Most</author>
      <license>BSD</license>
      <helpPatch>midi_in.axh</helpPatch>
      <inlets>
         <int32 name="read" description="input of counter for the read-position of the sequencer. Count may go up to 32bits and pretty darn fast!"/>
         <int32 name="write" description="input of counter for the write-position of the sequencer. Count may go up to 32bits and pretty darn fast!"/>
         <bool32 name="restart" description="forces a re-run for finding current position &amp; last played note-&gt;in case it somehow screws up.."/>
         <int32 name="maxcount" description="maximum count that the counter will give. This may go up to 32bit!"/>
         <bool32 name="port" description="select output port: 0=internal 1=midi DIN output"/>
         <bool32 name="load" description="loads a saved sequence"/>
         <bool32 name="save" description="saves a sequence"/>
         <charptr32 name="filename" description="sets filename of saved/loaded sequence"/>
         <bool32 name="DelChnl" description="when high, deletes all notes from the channel of the incoming midi-note"/>
         <int32 name="fromMin" description="start-position for sequence copying"/>
         <int32 name="fromMax" description="end-position for sequence copying"/>
         <bool32 name="copy" description="when high, copies all the &quot;edit&quot; channels to other channels. The other channels are in the same order but have a channel-offset set by the &quot;toChannelOffset&quot; parameter."/>
         <int32 name="toMin" description="start-position for sequence copying"/>
         <int32 name="toMax" description="end-position for sequence copying. Times between start/end will be in ratio to the sizes of &quot;from&quot; and &quot;to&quot;.-&gt;you can stretch parts!"/>
         <bool32 name="delay" description="when high, adds a delayed version of the original channel to the &quot;original channel+toChannelOffset&quot;. The delay can thus be send over another channel!"/>
         <int32 name="time" description="Timing of the delay"/>
         <int32 name="transpose" description="transposition of the delay (useful to use the scaling for this!)"/>
         <frac32 name="tail" description="velocity fade-out for delayed notes"/>
         <int32 name="repeats" description="amount of delays that will be added"/>
         <bool32 name="bound" description="bounds the delays within the maximum count, otherwise it will add them beyond maximum count (eg. when you end, you just use a longer max-count and let it run out)"/>
         <bool32 name="erase" description="ERASES ALL CHANNELS! BOOM! NOTHING LEFT! Be sure to save your stuff if you want to keep it! ;)"/>
         <bool32 name="active" description="when high, the module is in active state. When low, resets and sends a all-notes-off"/>
         <int32 name="key" description="sets key of the internal scale-&gt; needs scale7bank/generator"/>
         <int32 name="scale" description="sets the scale of the internal scale... (say what?!?)-&gt; needs scale7bank/generator"/>
         <bool32 name="undo" description="undoes last 64 played notes... not sure if that&apos;s helpful... XD"/>
      </inlets>
      <outlets/>
      <displays/>
      <params>
         <bool32.mom name="CHANNEL internal/DIN 1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  G   1  2  3  4  5  6  7  8  9 A  B  C  D  E  F " description="just a bunch of names for the rows so you can see what you do :)"/>
         <bin32 name="edit" description="when high, this channel is open for editting (recording) and is used when &quot;copy&quot; or &quot;delay&quot; is used"/>
         <bin32 name="mute" description="when high, this channel is muted"/>
         <bin32 name="solo" description="when high, this channel is added to the &quot;solo&quot;"/>
         <bin32 name="scaled" description="when high, this channel listens to the scaling function, otherwise 12notes/oct"/>
         <int32 name="predelay" description="sets predelay to adjust for latency ">
            <MinValue i="0"/>
            <MaxValue i="1000"/>
         </int32>
         <int32 name="toChnlOffset" description="used by the &quot;copy&quot; and &quot;delay&quot; options to set a channel-offset. When a channel is in &quot;edit&quot; mode, this offset sets the channel to it&apos;s left(-)/right(+) (0=itself) that receives it&apos;s copy/delay">
            <MinValue i="-32"/>
            <MaxValue i="32"/>
         </int32>
      </params>
      <attribs>
         <combo name="size">
            <MenuEntries>
               <string>2</string>
               <string>4</string>
               <string>8</string>
               <string>16</string>
               <string>32</string>
               <string>64</string>
               <string>128</string>
               <string>256</string>
               <string>512</string>
               <string>1024</string>
               <string>2048</string>
               <string>4096</string>
               <string>8192</string>
               <string>16384</string>
               <string>32768</string>
               <string>65536</string>
               <string>131072</string>
               <string>262144</string>
               <string>524288</string>
               <string>1048576</string>
               <string>2097152</string>
               <string>4194304</string>
            </MenuEntries>
            <CEntries>
               <string>1</string>
               <string>2</string>
               <string>3</string>
               <string>4</string>
               <string>5</string>
               <string>6</string>
               <string>7</string>
               <string>8</string>
               <string>9</string>
               <string>10</string>
               <string>11</string>
               <string>12</string>
               <string>13</string>
               <string>14</string>
               <string>15</string>
               <string>16</string>
               <string>17</string>
               <string>18</string>
               <string>19</string>
               <string>20</string>
               <string>21</string>
               <string>22</string>
            </CEntries>
         </combo>
         <objref name="scale"/>
      </attribs>
      <depends>
         <depend>fatfs</depend>
      </depends>
      <code.declaration><![CDATA[static const uint32_t LENGTHPOW = (attr_size);
static const uint32_t LENGTH = (1<<attr_size);
static const uint32_t LENGTHMASK = ((1<<attr_size)-1);

uint16_t *array;
uint32_t count;
int i;
bool Ctrg;
int32_t S;
int timer[128];
bool trg;
bool prg;
int T;
bool ctrg;
bool ON[128];
int Port;
bool strig;
bool ltrig;
uint32_t CH;
uint32_t cHn;
int D;
bool dtrg;
bool srg;
bool qrg;
bool Dtrg;
int ChL;
bool erase;
bool upd;
uint32_t MUTE;
uint32_t SOLO;
uint32_t KEYED;
int edit;
bool Atrg;
uint16_t semitone;
int scale;
int key;
uint16_t last[2][64];
uint32_t CNT;
bool UNDO;
uint32_t K;]]></code.declaration>
      <code.init><![CDATA[static uint16_t _array[LENGTH*4] __attribute__ ((section (".sdram")));
array = &_array[0];

for(i=0;i<LENGTH;i++){
	array[i<<2]=65534;
}

for(i=0;i<LENGTH*3;i++){
	int j=i<<2;;
	array[j+1]=0;
	array[j+2]=0;
	array[j+3]=0;
}


S=0;
trg=0;
for(i=0;i<128;i++){
	ON[i]=0;
}
for(i=0;i<64;i++){
	last[0][i]=65534;
	last[1][i]=65534;
}
CNT=0;]]></code.init>
      <code.krate><![CDATA[//load sequence
if ((inlet_load>0) && !ltrig) {
    ltrig=1;
    FIL FileObject;
    FRESULT err;
    UINT bytes_read;
    codec_clearbuffer();
    err = f_open(&FileObject, inlet_filename, FA_READ | FA_OPEN_EXISTING);
    if (err != FR_OK) { report_fatfs_error(err,inlet_filename); return;}
    int rem_sz = sizeof(*array)*LENGTH*4;
    int offset = 0;
    while (rem_sz>0) {
      if (rem_sz>sizeof(fbuff)) {
        err = f_read(&FileObject, fbuff, sizeof(fbuff),&bytes_read);
        if (bytes_read == 0) break;
        memcpy((char *)(&array[0]) + offset,(char *)fbuff,bytes_read);
        rem_sz -= bytes_read;
        offset += bytes_read;
      } else {
        err = f_read(&FileObject, fbuff, rem_sz,&bytes_read);
        memcpy((char *)(&array[0]) + offset,(char *)fbuff,bytes_read);
        rem_sz = 0;
      }
    }    if (err != FR_OK) { report_fatfs_error(err,inlet_filename); return;};
    err = f_close(&FileObject);
    if (err != FR_OK) { report_fatfs_error(err,inlet_filename); return;};
  }
  else if (!(inlet_load>0)) ltrig=0;


//save sequence
if ((inlet_save>0) && !strig) {
    strig=1;
    FIL FileObject;
    FRESULT err;
    UINT bytes_written;
    codec_clearbuffer();
    err = f_open(&FileObject, inlet_filename, FA_WRITE | FA_CREATE_ALWAYS);
    if (err != FR_OK) {report_fatfs_error(err,inlet_filename); return;}
    int rem_sz = sizeof(*array)*LENGTH*4;
    int offset = 0;
    while (rem_sz>0) {
      if (rem_sz>sizeof(fbuff)) {
        memcpy((char *)fbuff,(char *)(&array[0]) + offset, sizeof(fbuff));
        err = f_write(&FileObject, fbuff, sizeof(fbuff),&bytes_written);
        rem_sz -= sizeof(fbuff);
        offset += sizeof(fbuff);
      } else {
        memcpy((char *)fbuff,(char *)(&array[0]) + offset, rem_sz);
        err = f_write(&FileObject, fbuff, rem_sz, &bytes_written);
        rem_sz = 0;
      }
    }    if (err != FR_OK) report_fatfs_error(err,inlet_filename);
    err = f_close(&FileObject);
    if (err != FR_OK) report_fatfs_error(err,inlet_filename);
  }
  else if (!(inlet_save>0)) strig=0;

scale=inlet_scale;
scale=scale-scale/46*46;
scale=scale<0?scale+46:scale;
scale=scale*7;

key=(inlet_key)*5;
key=key-(key/12)*12;
key=key<0?key+12:key;




//select edit-channel
if(upd){
if(edit==1){PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_mute],MUTE,0xFFFD);}
if(edit==0){PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_edit],cHn,0xFFFD);}
if(edit==2){PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_solo],SOLO,0xFFFD);}
if(edit==3){PExParameterChange(&parent->PExch[PARAM_INDEX_attr_legal_name_scaled],KEYED,0xFFFD);}
upd=0;
}
MUTE=param_mute;
cHn=param_edit;
SOLO=param_solo;
KEYED=param_scaled;

//erase all channels
if((inlet_erase>0)&&!erase){
	erase=1;
	for(i=0;i<LENGTH;i++){
	array[i<<2]=65534;
}

for(i=0;i<LENGTH*3;i++){
	int j=i<<2;;
	array[j+1]=0;
	array[j+2]=0;
	array[j+3]=16;
}
}
else if(inlet_erase==0){erase=0;}


//delete selected edit-channels
if(((inlet_DelChnl>0)&&!dtrg)&&(ChL>-1)){
	dtrg=1;
	D=0;
	for(i=0;i<LENGTH;i++){
		if((i+D)<LENGTH){
		array[(i<<2)]=array[((i+D)<<2)];
		array[(i<<2)+1]=array[((i+D)<<2)+1];
		array[(i<<2)+2]=array[((i+D)<<2)+2];
		array[(i<<2)+3]=array[((i+D)<<2)+3];
		//if((cHn>>array[(i<<2)+3])&1)
		if((ChL==array[(i<<2)+3]))
		{	
			D+=1;
			i-=1;
		}}
		else	
		{array[i<<2]=65535;
		 array[(i<<2)+2]=0;
		 array[(i<<2)+3]=16;
		 }
	}
		if(ChL>15)
		{	
			MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_CONTROL_CHANGE + (ChL-16),MIDI_C_ALL_NOTES_OFF,0);
		}
		if(ChL<16)
		{
			PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_CONTROL_CHANGE + ChL,MIDI_C_ALL_NOTES_OFF,0);
		}	
}
else if((inlet_DelChnl==0)&&(!(ChL>-1))){dtrg=0;}

//undo last 64 notes
if((inlet_undo>0)&&!UNDO){
CNT=0;
UNDO=1;
for(i=0;i<64;i++){
	if(!(last[0][i]==65534)){
	K=0;
	while(((!(last[0][i]==array[K]))&&(!(last[1][i]==array[K+1])))&&!(K>(LENGTH<<2))){
		K+=4;
	}
	if(K<(LENGTH<<2)){
	int B;
	for(B=K;B<LENGTH;B++){
	int k=B<<2;
		array[k]=array[k+4];
		array[k+1]=array[k+5];
		array[k+2]=array[k+6];
		array[k+3]=array[k+7];
	}
last[0][i]=65534;
last[1][i]=65534;}
}
}}
else if(inlet_undo==0){UNDO=0;}

//copy selected edit-channels to channel offset
if((inlet_copy>0)&&!Ctrg){
	

for(i=0;i<LENGTH;i++)
{     
      if((array[(i<<2)]>=inlet_fromMin)&&(array[(i<<2)]<inlet_fromMax)&&((cHn>>array[(i<<2)+3])&1))
      {
     	uint32_t Y=(int64_t)(array[(i<<2)]-inlet_fromMin)*(inlet_toMax-inlet_toMin)/(inlet_fromMax-inlet_fromMin)+inlet_toMin;
          int F=0;srg=0;
     	while((Y>=array[F])&&!srg)
     		{
				F+=4;
				if((F>>2)>=LENGTH){
				srg=1;}
			}
		if(!srg)
		{
			int l;
			for(l=LENGTHMASK;l>(F/4);l--)
				{
					int k=l<<2;
					array[k]=array[k-4];
					array[k+1]=array[k-3];
					array[k+2]=array[k-2];
					array[k+3]=array[k-1];
				}
			array[F]=Y;
      		array[F+1]=array[(i<<2)+1];
      		array[F+2]=array[(i<<2)+2];
      		array[F+3]=array[(i<<2)+3]+80;
      		
      		if(array[i<<2]>=Y)
      		{
      			i+=1;
      		}
      	}
      }
}
for(i=0;i<LENGTH;i++){
	if(array[(i<<2)+3]>79){
		array[(i<<2)+3]-=80-param_toChnlOffset;
	}
}
Ctrg=1;
}
else if(inlet_copy==0){Ctrg=0;}
bool bound=inlet_bound;


//repeating delay selected edit-channels to channel offset
if((inlet_delay>0)&&!Dtrg){
	

for(i=0;i<LENGTH;i++)
{     
      if((array[(i<<2)]>=inlet_fromMin)&&(array[(i<<2)]<inlet_fromMax)&&((cHn>>array[(i<<2)+3])&1)&&(array[(i<<2)+3]<80))
      {
     	int H;
     	for(H=0;H<inlet_repeats;H++)
     	{
     		int32_t Z=(uint32_t)array[(i<<2)]+inlet_time*(H+1);
     		if(bound>0)
     		{
     			int32_t rng=inlet_fromMax-inlet_fromMin;
     			Z=Z-((Z/rng)*rng)+inlet_fromMin;
     		}
         		uint32_t F=0;qrg=0;
     		while((Z>=array[F])&&!qrg)
     			{
				F+=4;
				if((F>>2)>=LENGTH){
				qrg=1;}
				}
			if(!qrg)
			{
				int l;
				for(l=LENGTHMASK;l>(F>>2);l--)
				{
					int k=l<<2;
					array[k]=array[k-4];
					array[k+1]=array[k-3];
					array[k+2]=array[k-2];
					array[k+3]=array[k-1];
				}
				array[F]=Z;
      			array[F+1]=(array[(i<<2)+1]+(H+1)*inlet_transpose)&255;
      			array[F+1]=array[F+1]>127?256-array[F+1]:array[F+1];
      			array[F+2]=__USAT(array[(i<<2)+2]-___SMMUL(array[(i<<2)+2]<<2,((1<<27)-inlet_tail)*(H+1)),16);
      			array[F+3]=array[(i<<2)+3]+80;
      			if(array[i<<2]>=Z){
      			i+=1;}
      		}
      	}
      }
}
int X;
for(X=0;X<LENGTH;X++){
if(array[(X<<2)+3]>79){
   array[(X<<2)+3]-=80-param_toChnlOffset;}
}

Dtrg=1;
}
else if((inlet_delay==0)&&Dtrg){Dtrg=0;}

//get count
count=inlet_read+inlet_maxcount;
count=count-count/inlet_maxcount*inlet_maxcount;

//reset array-read position
if((count==0)&&!ctrg){
	T=0;
	ctrg=1;
}
if((count>0)&&ctrg){ctrg=0;}

while(count>=array[T]){
CH=T+3;
if(((!((MUTE>>array[CH])&1))&&((!(SOLO>0))||(((SOLO>>array[CH])&1))))&&(count==array[T])) //(count==array[T]) for exact play at count
{	
	if((((KEYED>>array[CH])&1))){
	uint16_t pitch=array[T+1]-7;
	uint16_t octave=pitch/7;
	semitone=pitch-octave*7;
	semitone=(attr_scale.note[semitone+scale]+octave*12)+key-4;}
	else{semitone=array[T+1];} 
	//semitone=array[T+1];
if(array[T+2]>1){	
if(array[CH]>15)
{	
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_NOTE_ON + (array[CH]-16),semitone,array[T+2]);}
if(array[CH]<16)
{	
	
	PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,MIDI_NOTE_ON + array[CH],semitone,array[T+2]);}
}
if(array[T+2]<1){
if(array[CH]>15)
{	
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_NOTE_OFF + (array[CH]-16),semitone,64);}
if(array[CH]<16)
{	
	PatchMidiInHandler((midi_device_t) 0,0,MIDI_NOTE_OFF + array[CH],semitone,64);}}}
T+=4;
}

Port=inlet_port>0?16:0;


//cHn=cHn>>16;

count=inlet_write+inlet_maxcount-param_predelay;
count=count-count/inlet_maxcount*inlet_maxcount;

if((inlet_active==0)&&!Atrg){
	for(i=0;i<16;i++){
	MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_CONTROL_CHANGE + i,MIDI_C_ALL_NOTES_OFF,0);}
	Atrg=1;
}
else if(inlet_active==1){Atrg=0;}]]></code.krate>
      <code.midihandler><![CDATA[/*
0=position;
1=note;
2=velocity (0 == off) (>0 == on)
3=channel
*/

if(port==1){

if ((status >= MIDI_NOTE_ON)&&(status <= MIDI_NOTE_ON+15) && (data2)) {
	
	ChL=status - MIDI_NOTE_ON+(Port);
	if(((cHn>>status-MIDI_NOTE_ON+16)&1)||((cHn>>status-MIDI_NOTE_OFF+16)&1)){	
	S=0;
	trg=0;

	while((count>=array[S])&&!trg)
	{
		S+=4;
		if((S>>2)>=LENGTH)
		{
			trg=1;
		}
	}
	
	if(!trg)
	{
	for(i=LENGTHMASK;i>(S/4);i--)
		{
		int k=i<<2;
		array[k]=array[k-4];
		array[k+1]=array[k-3];
		array[k+2]=array[k-2];
		array[k+3]=array[k-1];
		}
	}
last[0][CNT]=count;
last[1][CNT]=data1;
CNT=(CNT+1)&63;
array[S]=count;
array[1+S]=data1;
array[2+S]=data2;
array[3+S]=status - MIDI_NOTE_ON+(Port);
ON[data1]=1;
}
} else if ((((status >= MIDI_NOTE_ON)&&(status <= MIDI_NOTE_ON + 15) && (!data2))||
          (status >=  MIDI_NOTE_OFF )&&(status <=  MIDI_NOTE_OFF +15))&&(ON[data1]==1)) {
     ChL=-1;     	
if(((cHn>>(status-MIDI_NOTE_ON+16))&1)||((cHn>>(status-MIDI_NOTE_OFF+16))&1)){   
	       	
S=0;
trg=0;
while((count>=array[S])&&!prg){
	S+=4;
	if((S>>2)>=LENGTH){
	prg=1;}
}
if(!prg){
for(i=LENGTHMASK;i>(S/4);i--){
	int k=i<<2;
	array[k]=array[k-4];
	array[k+1]=array[k-3];
	array[k+2]=array[k-2];
	array[k+3]=array[k-1];
}}
last[0][CNT]=count;
last[1][CNT]=data1;
CNT=(CNT+1)&63;
array[S]=count;
array[1+S]=data1;
array[2+S]=0;
if((status >= MIDI_NOTE_ON)&&(status <= MIDI_NOTE_ON + 15)){
array[3+S]=(status - MIDI_NOTE_ON)+(Port);}
if((status >=  MIDI_NOTE_OFF )&&(status <=  MIDI_NOTE_OFF +15)){
array[3+S]=(status - MIDI_NOTE_OFF)+(Port);}


ON[data1]=0;
}

}

int8_t DATA;
if((status)&&(!((status&15)==0))){
	if((status==((status&15)+MIDI_NOTE_ON))||(status==((status&15)+MIDI_NOTE_OFF))){
	
	if((((uint32_t)KEYED>>(status&15)+16)&1)){
		
	uint16_t pitch=data1-7;
	uint16_t octave=pitch/7;
	DATA=pitch-octave*7;
	DATA=(attr_scale.note[DATA+scale]+octave*12)+key-4;}
	else{DATA=data1;}
	}
	else {DATA=data1;}

if(Port>15){
MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, status,DATA,data2);}
else if((Port<16)&&(1==0))												
{PatchMidiInHandler(MIDI_DEVICE_INTERNAL,0,status,DATA,data2);}}  
}

if ((status == 0+ MIDI_CONTROL_CHANGE)&&(data1 > 56)&&(data1<61)) {
edit=(data1-57)&3;
	for(i=0;i<16;i++)
	{
		if(edit==0)
		{
			if((cHn>>(i+16))&1){MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 1,((i+8)&15)*2+97,64);}
						else{MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_OFF + 1,((i+8)&15)*2+97,64);}
		}
		if(edit==1)
		{
			if((MUTE>>(i+16))&1){MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 1,((i+8)&15)*2+97,64);}
						else{MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_OFF + 1,((i+8)&15)*2+97,64);}
		}
		if(edit==2)
		{
			if((SOLO>>(i+16))&1){MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 1,((i+8)&15)*2+97,64);}
						else{MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_OFF + 1,((i+8)&15)*2+97,64);}
		}
		if(edit==3)
		{
			if((KEYED>>(i+16))&1){MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_ON + 1,((i+8)&15)*2+97,64);}
						else{MidiSend3((midi_device_t) MIDI_DEVICE_USB_HOST, 1, MIDI_NOTE_OFF + 1,((i+8)&15)*2+97,64);}
		}
		
	}

}

 if ((status == 1+ MIDI_CONTROL_CHANGE)&&(data1 > 0)&&(data1<17)) {
 if(edit==0){
 uint32_t TMP1=cHn&((1<<15+data1)-1);
 uint32_t TMP2=(uint32_t)(cHn>>(16+data1))<<(16+data1);
 cHn=TMP1+TMP2+(data2>0?(1<<(data1+15)):0);
 }
 if(edit==1){
 uint32_t TMP1=MUTE&((1<<15+data1)-1);
 uint32_t TMP2=(uint32_t)(MUTE>>(16+data1))<<(16+data1);
 MUTE=TMP1+TMP2+(data2>0?(1<<(data1+15)):0);
 MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_CONTROL_CHANGE + (data1-1),MIDI_C_ALL_NOTES_OFF,0);
 }
 if(edit==2){
 uint32_t TMP1=SOLO&((1<<15+data1)-1);
 uint32_t TMP2=(uint32_t)(SOLO>>(16+data1))<<(16+data1);
 SOLO=TMP1+TMP2+(data2>0?(1<<(data1+15)):0);
 }
 if(edit==3){
 uint32_t TMP1=KEYED&((1<<15+data1)-1);
 uint32_t TMP2=(uint32_t)(KEYED>>(16+data1))<<(16+data1);
 KEYED=TMP1+TMP2+(data2>0?(1<<(data1+15)):0);
 }
 upd=1;	
 }

 if ((status == 2+MIDI_CONTROL_CHANGE)&&(data1>13)&&(data1<17)){
 MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, status-(status&15),data1,data2);
 }]]></code.midihandler>
   </obj.normal>
</objdefs>