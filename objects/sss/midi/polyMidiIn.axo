<objdefs appVersion="1.0.11">
   <obj.normal id="polyMidiIn" uuid="42d6e672-1a53-4c28-876b-7b46922a8a8e">
      <sDescription>Monophonic MIDI keyboard note input, gate, velocity and release velocity. Polyphonic touch output.</sDescription>
      <author>Johannes Taelman</author>
      <license>BSD</license>
      <helpPatch>midi_in.axh</helpPatch>
      <inlets/>
      <outlets>
         <frac32.bipolar name="note" description="midi note number (-64..63)"/>
         <bool32 name="gate" description="key pressed, no retrigger legato"/>
         <frac32.positive name="velocity" description="note-on velocity"/>
         <frac32.positive name="touch" description="polyphonic aftertouch"/>
         <int32 name="index"/>
      </outlets>
      <displays/>
      <params/>
      <attribs/>
      <code.declaration><![CDATA[int8_t _note;
int8_t _gate;
uint8_t _velo;
uint8_t _touch;
int8_t note[8];
int8_t velocity[8];
int8_t gate[8];
int8_t touch[8];
int i;
int pos[8];
int32_t _active;
int32_t _pos;
int32_t _pos_shadow;
int32_t count;]]></code.declaration>
      <code.init><![CDATA[_gate = 0;
_note = 0;
_touch = 0;
for(i=0;i<8;i++){
	note[i]=0;
	gate[i]=0;
	velocity[i]=0;
	touch[i]=0;
	pos[i]=0;
}]]></code.init>
      <code.krate><![CDATA[int32_t sum=0;
int32_t tmp;
for(i=0;i<8;i++){
if(gate[i]>0){
pos[sum]=i;
sum+=1;
sum=sum>8?8:sum;
}}
int a=_gate;
while(a>0){
for(i=0;i<(sum-1>0?sum-1:0);i++){
a=0;
if(note[i]>note[i+1>=sum?sum-1:i+1]){
a=1;
tmp=note[i];
note[i]=note[i+1];
note[i+1]=tmp;
tmp=velocity[i];
velocity[i]=velocity[i+1];
velocity[i+1]=tmp;
tmp=touch[i];
touch[i]=touch[i+1];
touch[i+1]=tmp;
}
}
}
//count=_pos/6;
//count=count-(count/sum)*sum;
//outlet_note=note[count];
//outlet_gate=gate[count];
//outlet_velocity=velocity[count];
//outlet_touch=touch[count];]]></code.krate>
      <code.midihandler><![CDATA[if ((status == MIDI_NOTE_ON + attr_midichannel) && (data2)) {
  velocity[parent->polyIndex] = data2;
  note[parent->polyIndex] = data1;
  gate[parent->polyIndex] = 1;

} else if (((status == MIDI_NOTE_ON + attr_midichannel) && (!data2))||
          (status == MIDI_NOTE_OFF + attr_midichannel)) {
  if (note[parent->polyIndex] == data1) {
    gate[parent->polyIndex] = 0;
  }
} else if ((status == attr_midichannel + MIDI_POLY_PRESSURE)&&(data1 == note[parent->polyIndex])) {
  touch[parent->polyIndex] = data2;
} else if ((status == attr_midichannel + MIDI_CONTROL_CHANGE)&&(data1 == MIDI_C_ALL_NOTES_OFF)) {
  gate[parent->polyIndex] = 0;
}

if (status == MIDI_TIMING_CLOCK) {
  _pos_shadow++;
  _pos = _pos_shadow;
} else if (status == MIDI_START) {
  _active = 1;
  _pos = 0;
  _pos_shadow = -1;
} else if (status == MIDI_STOP) {
  _active = 0;
  _pos = -1;
} else if (status == MIDI_CONTINUE) {
  _active = 1;
} else if (status == MIDI_SONG_POSITION) {
  _pos_shadow = 6*((data2<<7)+data1)-1;
}]]></code.midihandler>
   </obj.normal>
</objdefs>