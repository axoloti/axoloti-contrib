<objdefs appVersion="1.0.11">
   <obj.normal id="polyRyTrig" uuid="6bce5f44-f583-430e-a2a7-23a53da1f458">
      <sDescription>Module to provide a tempo-synced and controlled trigger. To be used with the &quot;polycountMan&quot; module to make polyrythmic trigger sequences.
Triggers are generated by an internal LFO, host-synced through the &quot;timing&quot; input-&gt;connect this to the &quot;sss/midi/clock&quot; module&apos;s &quot;time&quot; output or use the &quot;timing/clock2timing&quot; module together with an LFO to provide the time.

For the amount of triggers per stage (set by the amount of measures), you can use the &quot;Mselect&quot; switch to switch between the internal array (off) (edited with the &quot;arrayEdit&quot; module) and the &quot;measures&quot; input(on). 
When &quot;on&quot; the trigger-rate will follow the stage-length even if the internal array is set to another value, result is that the rate stays the same for each stage, no matter the measures-length.
When &quot;off&quot;, the &quot;select&quot; input selects from the internal table the amount of triggers to be generated within the time that the current amount of measures will take (measureInput*timing/triggers=triggerTiming).
Lastly, the triggerTiming can be further divided by the &quot;rate&quot; input. This is useful for creating quick fills.

The &quot;rst&quot; input resets the internal LFO and should be connected to the &quot;c&quot; output of the polyCount module (stage trigger).
The &quot;active&quot; input should be connected to either the &quot;active&quot; output on the polyCount module or a toggle-button to switch it on manually.</sDescription>
      <author>Remco van der most</author>
      <license>BSD</license>
      <inlets>
         <int32 name="timing"/>
         <int32 name="measures"/>
         <int32 name="select"/>
         <int32 name="rate"/>
         <bool32 name="rst"/>
         <bool32 name="active"/>
         <bool32 name="save"/>
         <bool32 name="load"/>
         <charptr32 name="filename"/>
      </inlets>
      <outlets>
         <bool32 name="trig"/>
         <int32 name="rate"/>
      </outlets>
      <displays/>
      <params>
         <bool32.tgl name="Mselect" noLabel="true"/>
         <frac32.u.map name="pattern"/>
         <bool32.mom name="save"/>
         <bool32.mom name="load"/>
      </params>
      <attribs>
         <spinner name="maxstages" MinValue="1" MaxValue="16" DefaultValue="0"/>
         <spinner name="patterns" MinValue="1" MaxValue="128" DefaultValue="1"/>
      </attribs>
      <depends>
         <depend>fatfs</depend>
      </depends>
      <code.declaration><![CDATA[static const uint32_t LENGTH = attr_maxstages;
static const int patt=attr_patterns;
uint8_t *array;
int32_t count;
int rtrig;
int strig;
int ltrig;
int length;]]></code.declaration>
      <code.init><![CDATA[static uint8_t _array[LENGTH*patt] __attribute__ ((section (".sdram")));
array = &_array[0];]]></code.init>
      <code.krate><![CDATA[int save=param_save+inlet_save;
int load=param_load+inlet_load;


if ((save>0) && !strig) {
    strig=1;
    FIL FileObject;
    FRESULT err;
    UINT bytes_written;
    err = f_open(&FileObject, inlet_filename, FA_WRITE | FA_CREATE_ALWAYS);
    if (err != FR_OK) {report_fatfs_error(err,"inlet_filename"); return;}
    int rem_sz = sizeof(*array)*(LENGTH*patt);
    int offset = 0;
    while (rem_sz>0) {
      if (rem_sz>sizeof(fbuff)) {
        memcpy((char *)fbuff,(char *)(&array[0]) + offset, sizeof(fbuff));
        err = f_write(&FileObject, fbuff, sizeof(fbuff),&bytes_written);
        rem_sz -= sizeof(fbuff);
        offset += sizeof(fbuff);
      } else {
        memcpy((char *)fbuff,(char *)(&array[0]) + offset, rem_sz);
        err = f_write(&FileObject, fbuff, rem_sz, &bytes_written);
        rem_sz = 0;
      }
    }    if (err != FR_OK) report_fatfs_error(err,"inlet_filename");
    err = f_close(&FileObject);
    if (err != FR_OK) report_fatfs_error(err,"inlet_filename");
  }
  else if (!(save>0)) strig=0;


  if ((load>0) && !ltrig) {
    ltrig=1;
    FIL FileObject;
    FRESULT err;
    UINT bytes_read;
    err = f_open(&FileObject, inlet_filename, FA_READ | FA_OPEN_EXISTING);
    if (err != FR_OK) { report_fatfs_error(err,inlet_filename); return;}
    int rem_sz = sizeof(*array)*(LENGTH*patt);
    int offset = 0;
    while (rem_sz>0) {
      if (rem_sz>sizeof(fbuff)) {
        err = f_read(&FileObject, fbuff, sizeof(fbuff),&bytes_read);
        if (bytes_read == 0) break;
        memcpy((char *)(&array[0]) + offset,(char *)fbuff,bytes_read);
        rem_sz -= bytes_read;
        offset += bytes_read;
      } else {
        err = f_read(&FileObject, fbuff, rem_sz,&bytes_read);
        memcpy((char *)(&array[0]) + offset,(char *)fbuff,bytes_read);
        rem_sz = 0;
      }
    }    if (err != FR_OK) { report_fatfs_error(err,inlet_filename); return;};
    err = f_close(&FileObject);
    if (err != FR_OK) { report_fatfs_error(err,inlet_filename); return;};
  }
  else if (!(load>0)) ltrig=0;



int32_t Patt=___SMMUL(__USAT(param_pattern,27)<<2,patt-1<<3);
Patt=Patt-Patt/patt*patt;
Patt=Patt*LENGTH;

int rate=inlet_select;
rate=rate-rate/length*length;
int32_t timing=inlet_timing*inlet_measures/(param_Mselect>0?inlet_measures:array[rate+Patt])/(inlet_rate>0?inlet_rate:1);
if((inlet_rst)&&!rtrig){
	rtrig=1;
	count=-1;
}
else if(inlet_rst==0){rtrig=0;}
count+=1;
count=count>=timing?0:count;
outlet_trig=(count<(timing>>1))&&inlet_active;
outlet_rate=array[rate+Patt];]]></code.krate>
   </obj.normal>
</objdefs>