<objdefs appVersion="1.0.8">
    <obj.normal id="nmpgen2" uuid="f4aa3eb936415b6fc796e576dde754a273a022ac" sha="dd90350d5d9fb8512e8bc1ce69ec962871607f0c">
        <upgradeSha>6a81606bcc6a29c922883f893193c4ff3d14c5a</upgradeSha>
        <sDescription>32-step Pseudo-random (repeatable) pattern generator. Based on Nord modular PatternGen module.</sDescription>
        <author>toneburst</author>
        <license>BSD</license>
        <helpPatch>nmpgen2.axh</helpPatch>
        <inlets>
            <bool32.rising name="trig" description="Trigger Pulse" />
            <bool32.rising name="r" description="Reset Pulse" />
        </inlets>
        <outlets>
            <frac32.bipolar name="out" description="Pattern Out (Bipolar)" />
        </outlets>
        <displays />
        <params>
            <frac32.u.map name="bank" description="Pattern Bank" />
            <frac32.u.map name="pattern" description="Pattern" />
            <frac32.u.map name="length" description="Pattern Length 2-32 steps" />
            <frac32.u.map name="offset" description="Pattern Offset" />
        </params>
        <attribs>
            <!--<spinner name="length" description="Pattern Length" MinValue="0" MaxValue="128" DefaultValue="16" />-->
        </attribs>
        <code.declaration><![CDATA[

int32_t pattern[32] = {};
int32_t counter = 0;
int32_t length = 2;
int32_t minlength = 1;
int32_t offset = 0;
int ntrig = 0;
int rtrig = 0;
int32_t bindex;
int32_t pindex;
int32_t outval;
bool init = false;

///////////////////////
// Utility Functions //
///////////////////////

// Return Max of 2 values
int32_t max(int32_t minval, int32_t val) {
    return(val >= minval) ? val : minval;
}

// Return Min of 2 values
int32_t min(int32_t maxval, int32_t val) {
    return(val <= maxval) ? val : maxval;
}

// Calculate pattern length based on param_length
int32_t calculatelength(int32_t len) {
    // Max 32 steps
    return max(minlength, len >> 22);
    // Max 64 steps
    //return max(minlength, len >> 21);
    // Max 128 steps
    //return max(minlength, len >> 20);
    // Max 256 steps
    //return max(minlength, len >> 19);
}

// Calculate step-offset value based on param_offset
int32_t calculateoffset(int32_t offs, int32_t maxoffs) {
    // Max 32 steps
    return min(offs >> 22, maxoffs);
    // Max 64 steps
    //return min(offs >> 21, maxoffs);
    // Max 128 steps
    //return min(offs >> 20, maxoffs);
    // Max 256 steps
    //return min(offs >> 19, maxoffs);
}

/////////////////////////////////////////////////////////////////////////
// Seeded Random Number Generator ///////////////////////////////////////
// http://blog.embedded-office.com/en/blog-artikel/items/random-1.html //
// (cryptographically rubbish, but should be fine for our porpoises) ////
/////////////////////////////////////////////////////////////////////////

int32_t rstate = 1;

int32_t updatestate() {
	int32_t a = 5;
	int32_t b = 12345;
	int32_t m = 511;
	rstate = ((rstate * a + b) % m) - 255;
	return rstate;
}

//////////////////////////
// Update Pattern Array //
//////////////////////////

void newpattern(int32_t a, int32_t b) {
	rstate = a * 64 + b;
	for(int i = 0; i < 32; i++) {
		pattern[i] = updatestate();
	}
}

        ]]>
        </code.declaration>
        <code.krate><![CDATA[

///////////////////////////////
// Loop Running For 1st Time //
///////////////////////////////

if (!init) {
	newpattern(param_bank, param_pattern);
    length = calculatelength(param_length);
    offset = calculateoffset(param_offset, length);
	init = true;
}

/////////////////////////////
// Reset Input Rising Edge //
/////////////////////////////

if ((inlet_r > 0) && !rtrig) {
    rtrig = 1;
    counter = 0;
} else if (!(inlet_r > 0)) {
    rtrig = 0;
}

///////////////////////////////
// Trigger Input Rising Edge //
///////////////////////////////

if ((inlet_trig > 0) && !ntrig) {
    // Check for changes to parameters
    // and regenerate array if params changed
	if ((param_bank != bindex) || (param_pattern != pindex)) {
		newpattern(param_bank, param_pattern);
		bindex = param_bank;
		pindex = param_pattern;
	}
    // Update/reset counter
    length = calculatelength(param_length);
    offset = calculateoffset(param_offset, length);
    // Set output value until next trigger
    outval = pattern[(counter + offset) % length];
    counter++;
    ntrig = 1;
} else if (!(inlet_trig > 0)) {
    ntrig = 0;
}

outlet_out = outval << 19;

    ]]>
    </code.krate>
    </obj.normal>
</objdefs>
