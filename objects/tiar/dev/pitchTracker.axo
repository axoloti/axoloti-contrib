<objdefs appVersion="1.0.12">
   <obj.normal id="pitchTracker" uuid="6d81c116-3190-40e5-baed-2eeaf7268caf">
      <sDescription></sDescription>
      <author>SmashedTransistors</author>
      <license>LGPL</license>
      <helpPatch>pitchTracker.axh</helpPatch>
      <inlets>
         <frac32buffer name="in"/>
      </inlets>
      <outlets>
         <frac32 name="pitch" description="out"/>
      </outlets>
      <displays/>
      <params/>
      <attribs/>
      <code.declaration><![CDATA[static const int PEAK_HIST_LENGTH = 32;
static const int PEAK_HIST_LENGTH_MASK = PEAK_HIST_LENGTH - 1;
// en sample 1ms = 48 10ms=480
static const int SELECT_REF_TIME_LIMIT=240;
//on choisit la meilleure ref parmi les 5 premiers pics
static const int SELECT_REF_NB_LIMIT=5;

//log2(x) en q21 sur l'intervalle [0,5 1]
int32_t tiarLog2q21[65] = {
   -2097152,  -2050243,  -2004050,  -1958552,  -1913729,  -1869559,  -1826025,  -1783109,
   -1740793,  -1699061,  -1657896,  -1617284,  -1577210,  -1537660,  -1498620,  -1460077,
   -1422019,  -1384434,  -1347311,  -1310637,  -1274402,  -1238596,  -1203210,  -1168232,
   -1133654,  -1099466,  -1065661,  -1032229,   -999162,   -966454,   -934094,   -902078,
    -870396,   -839043,   -808012,   -777295,   -746887,   -716782,   -686973,   -657456,
    -628223,   -599270,   -570592,   -542183,   -514038,   -486152,   -458521,   -431141,
    -404006,   -377112,   -350455,   -324030,   -297835,   -271864,   -246115,   -220583,
    -195264,   -170156,   -145254,   -120555,    -96057,    -71755,    -47647,    -23729,  0};

// entrée q14 sortie q21
int ln2Interp(int x) {
   int intPart = 18 - __CLZ(x);  // partie entiere du log2

   int scaledX = x >> intPart;   // mise à l'échelle [0,5 1] de l'entrée

   // calcul de la partie décimale à partir de scaledX
   // (interpolation de la table tiarLog2q21)
   int i = (scaledX >> 7) - 64;   // le -64 est là car on vise l'intervalle [0,5 1] pas  [0 1]
   int a = (scaledX & 127) << 24; //coef d'interpolation [0 1[ en q31
   int fracPart = ___SMMLA(a,tiarLog2q21[i + 1] - tiarLog2q21[i],tiarLog2q21[i] >> 1) << 1;

   return (intPart << 21) + fracPart;
}

class Peak {
	public:
	int type;
	long timeStamp;
	float floatTime;
	float v;
	float v0,v1,v2;
	float force;
	
	float delta(void){
		float a = v2 + v0 - 2*v1;
		if(a == 0) return 0;
			return 0.5f * (v2 - v0) / a;
	}
	
	void set(long _timeStamp, int _type, float _v0, float _v1, float _v2){
		timeStamp = _timeStamp;
		type = _type;
		v0 = _v0;
		v1 = _v1;
		v2 = _v2;
		force = 0;
		floatTime=timeStamp + delta();
		v=v1+0.25f*(v2-v0)*-delta();
	}
	
	// calcul fin du temps (avec v0 v1 v2)
	float getFloatTime(){
		return floatTime;
	}

};

class PeakHisto{
	public:
   Peak peaks[PEAK_HIST_LENGTH];
   int peakIndex=0;

   void init() {
   	peakIndex=0;
       for (int i = 0; i < PEAK_HIST_LENGTH; i++) {
           peaks[i].set(0,0,0,0,0);
       }
   }
   void put(long _timeStamp,int _type,float _v0,float _v1,float _v2){
       peakIndex--;
       peakIndex &= PEAK_HIST_LENGTH_MASK;
       peaks[peakIndex].set(_timeStamp,_type,_v0,_v1,_v2);

       //calcul de la force du précédent
       Peak p0 = get(0);
       Peak p1 = get(1);
       Peak p2 = get(2);
       float f01 = fabsf(p0.v - p1.v);
       float f12 = fabsf(p1.v - p2.v);
       float f = f01 < f12 ? f01 : f12;//min(f01, f12);
       p1.force = f;
   }
   Peak get(int i){
       return peaks[(peakIndex+i) & PEAK_HIST_LENGTH_MASK];
   }
};

float dv0 = 0, dv1 = 0, dv2 = 0; //local peak detector
long curTime=0;

//peak history
PeakHisto peaks;

float vFilt=0, vDC=0;


void proc(float v){
	curTime++;

	//recalage pour éviter les dérives de précision
	if(curTime == 2048){
		curTime=0;
		for(int i=0;i<PEAK_HIST_LENGTH;i++){
			peaks.peaks[i].floatTime-=2048;
		}
	}


	
	vDC += 0.0001f*(v-vDC);
	vFilt += 0.01f*(v-vDC-vFilt);
	dv2 = dv1;
	dv1 = dv0;
	dv0 = vFilt;//<----------------------
	if(dv1 > dv0 && dv1 >= dv2){
		peaks.put(curTime,1,dv0,dv1,dv2);
	}
	if(dv1 < dv0 && dv1 <= dv2){
		peaks.put(curTime,-1,dv0,dv1,dv2);
	}
}
int32_t calc(void){
   // select ref
   int iRef=1;
   float fMax= peaks.get(iRef).force;
   float time1=peaks.get(iRef).floatTime;
   for (int i = 2; i <= SELECT_REF_NB_LIMIT; i++) {

       Peak curP=peaks.get(i);
       if(time1 - curP.floatTime > SELECT_REF_TIME_LIMIT){
           break;
       }
       if(curP.force>fMax){
           fMax=curP.force;
           iRef=i;
       }
   }
   Peak ref = peaks.get(iRef);


   //recherche parmi les prédécesseurs
   int bestCandidate=-1;
   float bestDiffer=1e20;
   for (int iCandidat = iRef+2; iCandidat <= (PEAK_HIST_LENGTH-iRef)/2; iCandidat+=2) {
      
       float differ= diff(iRef, iCandidat);
      if(differ<bestDiffer){
      	bestDiffer=differ;
      	bestCandidate = iCandidat;
      }
   }
   if(bestCandidate<0) return -1<<27;
   float periode = peaks.get(iRef).getFloatTime()-peaks.get(bestCandidate).getFloatTime();
   if(periode<2)   return -1<<27;
   return 315060691 - (64<<21) - 12 * ln2Interp(arm::float_to_q(periode,14));
}

float diff(int iRef, int iCand){
        float acc = 0;
        float accTime=0;
        // on sautera les pics trop faibles
        int i0=0;
        int i1=0;
        float forceMin = 0.5f * peaks.get(iRef).force;
        Peak p0, p1;
        float t0=peaks.get(iRef).floatTime;
        float t1 = peaks.get(iCand).floatTime;
        // test sur 3 periodes
        int nbPeaks=0;
        float vMax=0;
        for (int i = 0; i < 2*(iCand-iRef); i++) {
            nbPeaks++;
            p0 = peaks.get(iRef  + i0);
            p1 = peaks.get(iCand + i1);
            acc += fabsf(p0.v - p1.v);
            if(fabsf(p0.v)>vMax)vMax=fabsf(p0.v);
            if(fabsf(p1.v)>vMax)vMax=fabsf(p1.v);

            accTime += fabsf((t0-p0.floatTime)-(t1-p1.floatTime));

            i0++;
            while(peaks.get(iRef  + i0).force < forceMin){
                i0 += 2;
            }
            i1++;
            while(peaks.get(iCand + i1).force < forceMin){
                i1 += 2;
            }
            if(i0+iRef>=PEAK_HIST_LENGTH){
                break;
            }
            if(i1+iCand>=PEAK_HIST_LENGTH){
                break;
            }
        }
        float errTime=accTime/(t0-t1);
        float errAmp=acc/vMax;

        return (0.05f*nbPeaks)+(errAmp+errTime)/nbPeaks;

    }]]></code.declaration>
      <code.krate><![CDATA[//outlet_pitch = 315060691 - 12 * ln2Interp(inlet_period >> (21-14)) - (64<<21);

outlet_pitch = calc();]]></code.krate>
      <code.srate><![CDATA[proc(arm::q_to_float(inlet_in,27));]]></code.srate>
   </obj.normal>
</objdefs>